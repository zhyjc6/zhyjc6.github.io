---
layout: mypost
title: 网络扫描技术原理与简单抓包分析
categories: [网络安全,科普]
---





## 前言

我们先自己在心里想一下，什么是网络扫描器？ 为什么需要网络扫描器？ 网络扫描器的主要功能？

1. 什么是网络扫描器？

   - 对于网络入侵者来说，网络扫描器是其收集信息的重要手段
   - 对于系统管理员来说，网络扫描器是保障系统安全的有效工具

   

2. 为什么需要网络扫描器？

   - 由于网络技术的飞速发展，网络规模迅猛增长和计算机系统日益复杂，导致新的系统漏洞层出不穷
   - 由于系统管理员的疏忽或缺乏经验，导致旧有的漏洞依然存在
   -  许多人出于好奇或别有用心，不停的窥视网上资源

   

3. 网络扫描器的功能？

   - 扫描目标主机识别其工作状态（开/关机） 
   - 识别目标主机端口的状态（监听/关闭）（进一步）
   - 识别目标主机系统及服务程序的类型和版本（更进一步）
   - 根据已知漏洞信息，分析系统脆弱点（再进一步）
   - 生成扫描结果报告（结果）

   

下面我将依次介绍网络扫描原理，然后简单使用两款知名扫描工具进行端口扫描，并抓包分析。



## 网络扫描原理

我们现在知道了网络扫描器的功能大致是四个模块：主机、端口、系统、漏洞。那么我们就分别从这四个模块来一一分析其实现原理。

### 1、主机扫描技术 

主机扫描是网络扫描的基础，也是第一步。我们需要利用主机扫描从一堆主机中扫描出存活的主机，然后以他们为目标进行后续的攻击。

其实主机扫描很简单，因为我们只需要证明其存活就好。那么我们怎么证明目标主机是存活的呢？想想存活主机和关闭主机的区别。对！我们只需要对目标主机发送特定的数据包，如果目标主机有回应，那么我们就认为该主机是存活的；反之如果对方不回应，我们就认为其不是存活主机。当然对方也不一定关机，这里就存在误判的可能。

**传统主机扫描技术**

1. ICMP Echo扫描

   向目标主机发送ICMP Echo Request (type 8)数据包，等待回复的ICMP Echo Reply 包(type 0) 。如果能收到，则表明目标系统可达，否则表明目标系统已经不可达或发送的包被对方的设备过滤掉。

   缺点是容易被防火墙屏蔽。 

2. Broadcast ICMP扫描 

   将ICMP请求包的目标地址设为广播地址或网络地址，则可以探测广播域或整个网络范围内的主机。

   缺点是并不是所有系统都支持此类请求包。 

3. Non-Echo ICMP扫描 

   一些其它ICMP类型包也可以用于对主机或网络设备的探测，如： 

   - Stamp Request(Type 13)，Reply(Type 14) 
   - Information Request(Type 15)，Reply(Type 16) 
   - Address Mask Request (Type 17)，Reply(Type 18)

以上是主机扫描的传统方法，也是常规方法。但是防火墙和网络过滤设备常常导致传统的探测手段变得无效。为了突破这种限制，必须采用一些非常规的手段。利用ICMP协议提供网络间传送错误信息的手段，往往可以更有效的达到目的：

1. 异常的IP包头

   向目标主机发送包头错误的IP包，目标主机或过滤设备会反馈ICMP Parameter Problem Error信息。常见的伪造错误字段为Header Length Field 和IP Options Field

2. 在IP头中设置无效的字段值

   在IP包中填充错误的字段值，目标主机或过滤设备会反馈ICMP Destination Unreachable信息。 

3. 错误的数据分片

   当目标主机接收到错误的数据分片（如某些分片丢失），并且在规定的时间间隔内得不到更正时，将丢弃这些错误数据包，并向发送主机反馈ICMP Fragment Reassembly Time Exceeded 错误报文。 



### 2、端口扫描技术 

当我们经过了主机扫描得到了存活主机，有了攻击目标后，我们就需要扫描目标主机的开放端口了。端口扫描技术主要分为三类：开放扫描、隐蔽扫描、半开放扫描。

**开放扫描**

会产生大量的审计数据，容易被对方发现，但其可靠性高； 	

1. TCP Connect 扫描 
   - 实现原理：通过调用socket函数connect()连接到目标计算机 上，完成一次完整的三次握手过程。如果端口处于侦听状态， 那么connect()就能成功返回。否则，这个端口不可用，即没有提供服务。 
   - 优点：稳定可靠，不需要特殊的权限 
   - 缺点：扫描方式不隐蔽，服务器日志会记录下大量密集的连接和错误记录 ，并容易被防火墙发现和屏蔽 

**隐蔽扫描**

能有效的避免对方入侵检测系统和防火墙的检测，但这种扫描使用的数据 包在通过网络时容易被丢弃从而产生错误的探测信息

1. TCP FIN 扫描 
   - 实现原理： 扫描器向目标主机端口发送FIN包。当一个FIN数据包到达一个关闭的端 口，数据包会被丢掉，并且返回一个RST数据包。否则，若是打开的端 口，数据包只是简单的丢掉（不返回RST）。 
   - 优点：由于这种技术不包含标准的TCP三次握手协议的任何部分，所以无法被记录下来，从而比SYN扫描隐蔽得多，FIN数据包能够通过只监测SYN 包的包过滤器。
   - 缺点：需要自己构造数据包，要求权限高； 通常适用于UNIX目标主机，但在Windows95/NT环境下，该方法无效。 因为不论目标端口是否打开，操作系统都返回RST包。
2. TCP Xmas扫描 
3. TCP Null 扫描 
   - 实现原理： TCP Xmas和Null扫描是FIN扫描的两个变种。Xmas扫描打开FIN， URG和PUSH标记，而Null扫描关闭所有标记。 这些组合的目的是为了通过对FIN标记数据包的过滤。 当此类数据包到达一个关闭的端口，数据包会被丢掉，并且返回一个 RST数据包。否则，若是打开的端口，数据包只是简单的丢掉（不返回 RST）。
   - 优点： 隐蔽性好； 
   - 缺点： 需要自己构造数据包，要求有超级用户或者授权用户权限； 通常适用于UNIX目标主机，而Windows系统不支持。
4. TCP ftp proxy扫描 
   - 实现原理：FTP代理连接选项，其目的是允许一个客户端同时跟两个FTP服务器建立连接，然后在服务器之间直接传输数据。然而，在大部分实现中，实际上能够使得FTP服务器发送文件到Internet的任何地方。该方法正是利用了这个缺陷，其扫描步骤如下： 
     - 1：假定S是扫描机，T是扫描目标，F是一个ftp服务器，这个服务器支持代理 选项，能够跟S和T建立连接。 
     - 2：S与F建立一个ftp会话，使用PORT命令声明一个选择的端口（称之为p－T ）作为代理传输所需要的被动端口。 
     - 3：然后S使用一个LIST命令尝试启动一个到p－T的数据传输。 
     - 4：如果端口p－T确实在监听，传输就会成功（返回码150和226被发送回给S ），否则S回收到"425无法打开数据连接"的应答。 
     - 5：S持续使用PORT和LIST命令，直到T上所有的选择端口扫描完毕。 
   - 优点：FTP代理扫描不但难以跟踪，而且可以穿越防火墙 
   - 缺点：一些ftp server禁止这种特性





**半开放扫描**

隐蔽性和可靠性介于前两者之间

1. TCP SYN 扫描 
   - 实现原理：扫描器向目标主机端口发送SYN包。如果应答是RST包，那么说明端口是关闭的；如果应答中包含SYN和ACK包，说明目标端口处于监听状态， 再传送一个RST包给目标机从而停止建立连接。由于在SYN扫描时，全连接尚未建立，所以这种技术通常被称为半连接扫描。 
   - 优点：隐蔽性较全连接扫描好，一般系统对这种半扫描很少记录。 
   - 缺点：通常构造SYN数据包需要超级用户或者授权用户访问专门的系统调用。 
2.  TCP间接扫描 
   - 实现原理：利用第三方的IP（欺骗主机）来隐藏真正扫描者的IP。由于扫描主机会对欺骗主机发送回应信息，所以必须监控欺骗主机的IP行为，从而获得原始扫描的结果。扫描主机通过伪造第三方主机IP地址向目标主机发起SYN扫描， 并通过观察其IP序列号的增长规律获取端口的状态 。 
   - 优点：隐蔽性好。 
   - 缺点：对第三方主机的要求较高。



以上都是基于TCP协议的端口扫描，其实还可以使用UDP协议进行端口扫描：

1. UDP端口扫描 
   - 向目标端口发送UDP 包。如果得到的应答为“ICMP port Unreachable”（ICMP 端口不可到达），那么目标端口是关闭 的。反之，如果没有收到这个应答消息，则目标端口极有可能是开放的。 
   - 由于UDP 是无连接的不可靠协议，UDP 扫描的准确性在很大程度上取决于网络及系统资源的使用率等多个因素。



### 3、栈指纹OS识别技术 

当我们得到了目标主机的开放端口后，我们还需要确定其使用的操作系统，因为不同的操作系统有不同的漏洞，这将影响我们后续的漏洞扫描。

介绍： [协议栈指纹](https://baike.baidu.com/item/%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%8C%87%E7%BA%B9/7113052)识别是一项强大的技术，能够以很高的概率迅速确定操作系统的版本。虽然TCP/IP协议栈的定义已经成为一项标准，但是各个厂家，如微软和RedHat等在编写自己的TCP/IP协议栈时，却做出了不同的解释。这些解释因具有独一无二的特性，故被称为“指纹”。通过这些细微的差别，可以准确定位操作系统的版本。 

原理：根据各个OS在TCP/IP协议栈实现上的不同特点，采用黑盒测 试方法，通过研究其对各种探测的响应形成识别指纹，进而识别目标 主机运行的操作系统。 

根据采集指纹信息的方式，又可以分为主动扫描和被动扫描两种方式。



**主动扫描**

采用向目标系统发送构造的特殊包并监控其应答的方式来识别操作系统类型

1.  ACK值

   不同系统在特定情况下对确认序列号的赋值是不同。例如，当攻击者发送一个设置了FIN、PSH、URG标识位的包到一个关闭TCP 端口时，大多数系统的应答包中，确认序列号为攻击者的初始序列数，而Windows 系统会设置确认序列号为会攻击者的初始序列数 加1 。

2. TCP ISN 取样

   不同系统选择的TCP序列数式样不同。低版本UNIX系统设为64K；Solaris，IRIX， FreeBSD等系统部份版本选用随机增量方式；Windows 系统用“时间相关”模型，每过一段时间ISN增加一个固定值。 

3.  ICMP错误信息终结

   一些操作系统限制各种错误信息的发送率。例如，Linux 内核限制目的不可达消息的生成每 4 秒钟80个。可发送数据包到多个随机的高UDP端口并计数收到的不可达消息

4.  ICMP消息引用

   ICMP错误消息可以引用一部分引起错误的源消息。对一个端口不可达消息，几乎所 有实现只送回IP请求头外加8个字节。然而，Solaris 送回的稍多，而Linux 更多。

主动扫描具有**速度快**、**可靠性高**等优点，但同样严重依赖于目标系统网络拓扑结构和过滤规则





**被动扫描**

通过Sniffer收集数据包，再对数据包的不同特征（TCP 包的 Windowsize、 IP 包的 TTL、TOS、DF位等参数）进行分析，来识别操作系统。 

被动扫描基本不具备攻击特征，具有很好的隐蔽性，但其实现严格依 赖扫描主机所处的网络拓扑结构；和主动探测相比较，具有**速度慢**、 **可靠性不高**等缺点

![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207134515.png)



### 4、漏洞扫描技术

原理：在端口扫描后得知目标主机开启的端口以及端口上的网络服务，将这些相关信息与网络漏洞扫描系统提供的漏洞库进行匹配，查看是否有满足匹配条件的漏洞存在。通过模拟黑客的攻击手法，对目标主机系统进行攻击性的安全漏洞扫描，如测试弱势口令等。若模拟攻击成功，则表明目标主机系统存在安全漏洞。

基于网络系统漏洞库的漏洞扫描的关键部分就是它所使用的漏洞库。 通过采用基于规则的匹配技术，即根据安全专家对网络系统安全漏洞、 黑客攻击案例的分析和系统管理员对网络系统安全配置的实际经验， 可以形成一套标准的网络系统漏洞库，然后再在此基础之上构成相应 的匹配规则，由扫描程序自动的进行漏洞扫描的工作。





## 使用X-Scan扫描

> X-Scan是国内最著名的综合扫描器之一，它是一款完全免费且不需要安装的绿色软件、界面支持中文和英文两种语言、包括图形界面和命令行方式。主要由国内著名的民间黑客组织“安全焦点”完成。X-Scan把扫描报告和安全焦点网站相连接，对扫描到的每个漏洞进行“风险等级”评估，并提供漏洞描述、漏洞溢出程序，方便相关人员测试、修补漏洞。 
>
> PS: 安全焦点网站目前已经不存在了，所以X-Scan扫描报告就没有数据接入。

### 1、TCP端口扫描

1. 扫描对象

   ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207134604.png)

   X-Scan的扫描对象可以是域名，也可以是IP。其中IP可以是指定的具体某一个IP或者是一个IP范围。
   
   当我们需要指定一个IP范围的时候可以使用192.168.0.1/24这样的简写来表示子网掩码为255.255.255.0，即扫描范围为192.168.0.1-192.168.0.255；也可以直接使用192.168.0.1-192.168.0.255来表示；最后还可以使用以上方式混合表示。
   
2. 开始主机扫描

   打开X-Scan gui，设置扫描参数

   ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207134700.png)

   ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207134724.png)

   开始扫描，wireshark抓包发现都是满屏的tcp syn包和rst包：

   ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207134746.png)

   选取一个攻击者发给目标机的SYN包，端口1218，我们发现包里没有数据，仅仅是把SYN标志位置为1，即SYN包：

   ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207134809.png)

   目标机的回应则是把ACK和RST位置为1，即此次TCP连接无效，说明目标机此端口未开放：

   ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207134842.png)

3. 那么什么样的情况才能说明端口开放呢？我们从扫描界面查看端口扫描结果，然后根据得到的目标即开放的端口去wireshark使用tcp端口过滤，得到端口对应的TCP包的详细信息：

   ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207134917.png)

   

   

4. 三次握手之一

   我们选择的是445端口，这是一个开放的端口。攻击者把SYN置为1，发送SYN 包给目标机，攻击者进入**SYN_SEND**状态：

   ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207134955.png)

5. 三次握手之二

   目标机收到SYN包，把ACK和SYN置为1，回送TCP-ACK包，表示收到了对方的TCP-SYN包，可以进行TCP连接。目标机进入**SYN_RCVD**状态。

   ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207135018.png)

6. 三次握手之三

   攻击者收到对方发送的TCP-ACK包,说明目标机同意建立连接，但是为了建立tcp连接，攻击者还需要发送一个TCP-ACK包表示确定建立TCP连接，此时双方进入 **ESTABLISHED** 状态。

   ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207135041.png)

7. 通过以上分析我们发现，为了扫描目标主机的开放端口，攻击者会遍历所有端口，并试图与其建立TCP连接，如果对方回复RST包，那么说明对方是没有监听此端口的，即端口未打开；如果成功建立了TCP连接，那么对方的该端口就是开放的，即有服务在监听此端口。



### 2、SYN端口扫描

1. 首先设置参数，检测方式为SYN，检测端口范围为1-65535：

   ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207135112.png)

2. 开始扫描，同时使用wireshark软件抓包：

   和TCP方式一样，还是发送满屏的SYN包，收到满屏的RST包：

   ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207135141.png)

3. 任意选择一个端口999追踪攻击者和目标机的数据包：

   ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207135211.png)

   ![](20191207135230.png)

4. 按照发包时间顺序依次查看数据包详细信息

   1. 攻击者发送SYN包请求与目标机999端口建立TCP连接：

      ![image-20191101232042833](image-20191101232042833.png)

   2. 目标机收到后发送了一个RST包请求重置连接，即表明此次TCP连接无效

      ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207135326.png)

   3. 之后攻击者又重复了两次，目标机均回复RST包：

      ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207135509.png)

      ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207135534.png)

      ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207135556.png)

      ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207135627.png)

5. 同样的道理，我们从扫描界面得到扫描出的目标机开放的端口，然后再跟踪相应的数据包：

   ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207135658.png)

6. 我们这次选择了554端口进行跟踪，我们惊喜的发现交互的数据包总共有7个，初步推测是TCP连接的三次握手和四次挥手：

   ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207135734.png)

   ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207135759.png)

7. 按照发包时间顺序依次查看攻击者和目标机之间的数据包

   1. 三次握手之一。攻击者把SYN置为1，发送SYN 包给目标机，攻击者进入**SYN_SEND**状态：

      ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207135826.png)

      

   2. 三次握手之二。目标机收到SYN包，把ACK和SYN置为1，回送TCP-ACK包，表示收到了对方的TCP-SYN包，可以进行TCP连接。目标机进入**SYN_RCVD**状态：

      ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207135854.png)

   3. 三次握手之三。攻击者收到对方发送的TCP-ACK包,说明目标机同意建立连接，但是为了建立tcp连接，攻击者还需要发送一个TCP-ACK包表示确定建立TCP连接，此时双方进入 **ESTABLISHED** 状态：

      ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207140002.png)

   4. 四次挥手之一

      攻击者发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。

      发送完毕后，攻击者进入 **FIN_WAIT_1**状态

      ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207140028.png)

   5. 四次挥手之二

      目标机端确认攻击者的 FIN 包，发送一个ACK包，表明自己接受到了攻击者关闭连接的请求，但还没有准备好关闭连接。

      发送完毕后，目标机进入 **CLOSE_WAIT** 状态，攻击者接收到这个ACK包之后，进入 **FIN_WAIT_2** 状态，等待目标机关闭连接。

      ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207140105.png)

   6. 四次挥手之三

      目标机准备好关闭连接时，向攻击者发送结束连接请求，FIN 、ACK置为1。

      发送完毕后，目标机进入 **LAST_ACK** 状态，等待来自攻击者的最后一个ACK包：

      ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207140141.png)

   7. 四次挥手之四

      攻击者接收到来自目标机的关闭请求，发送一个确认包，并进入 **TIME_WAIT**状态，等待可能出现的要求重传的 ACK 包。

      目标机接收到这个确认包之后，关闭连接，进入 **CLOSED** 状态。

      攻击者等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到目标机的 ACK ，认为目标机已经正常关闭连接，于是自己也关闭连接，进入 **CLOSED** 状态。

      ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207140211.png)

      

### 3、总结

二者都是试图建立TCP连接，并通过目标机回送的包来判断目标机该端口是否开放，如果不回复或者回复RST包，那么攻击者就认为目标机此端口不开放；如果攻击者和目标机成功建立了TCP连接，则攻击者认为目标机此端口是开放的。

二者的区别是：TCP扫描就是请求建立TCP连接，虽然经过了“三次握手”建立了TCP连接，但是连接之后不会主动断开；而SYN扫描则是攻击者请求建立TCP连接，经过“三次握手”建立TCP连接，过了一会，攻击者再经过“四次挥手” 请求断开TCP连接。







## 使用nmap扫描

Nmap，也就是Network Mapper，最早是Linux下的网络扫描和嗅探工具包。 

Nmap是一个网络连接端扫描软件，用来扫描网上电脑开放的网络连接端。确定哪些服务运行在哪些连接端，并且推断计算机运行哪个操作系统。它是网络管理员必用的软件之一，以及用以评估网络系统安全。 

其基本功能有三个

1. 探测一组主机是否在线；
2. 扫描 主机端口，嗅探所提供的网络服务；
3. 推断主机所用的操作系统 。 



常用参数：

- **-sS**  #  SYN扫描,又称为半开放扫描，它不打开一个完全的TCP连接，执行得很快，使用频率最高的扫描选项 
- **-sT**  #  当SYN扫描不能用时，TCP Connect()扫描就是默认的TCP扫描 
- **-sU**  #  UDP扫描用-sU选项,UDP扫描发送空的(没有数据)UDP报头到每个目标端口 
- **-sP**  #  PING扫描，打印出对扫描做出响应的主机,不做进一步测试 
- **-sO**  #  识别目标机操作系统

### 1、探测存活主机

**探测内网IP**

探测内网IP比较简单，攻击者只需要发送arp请求包探测目标ip是否在线，如果有arp回复包，则说明在线。此命令可以探测目标主机是否在线，如果在线，还可以得到其MAC地址。但是不会探测其开放的端口号。 

1. 首先我们打开Zenmap可视化界面，确定攻击目标和扫描方式。当我们输入攻击目标和扫描方式后，命令一栏会显示对应的nmap命令：**nmap -sn 192.168.109.1-255**

   ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207140312.png)

2. 攻击者使用wireshark抓包发现，攻击者直接发送ARP包广播目标机的IP地址，如果有主机回应，那么说明该主机是存活的：

   ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207140357.png)

3. 我们清楚的看到存活的主机都向攻击者回应了ARP包，攻击者可以获得目标机的MAC地址：

   ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207140429.png)

   ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207140456.png)

   ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207140524.png)

   ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207140812.png)

4. 客户端界面还提供了存活主机的网络拓扑图

   ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207140837.png)



**探测公网IP**

Nmap会发送四种不同类型的数据包来探测目标主机是否在线：

1. ICMP echo request
2. a TCP SYN packet to port 443(https)
3. a TCP ACK packet to port 80(http)
4. an ICMP timestamp request

依次发送四个报文探测目标机是否开启。只要收到其中一个包的回复，那就证明目标机开启。使用四种不同类型的数据包可以避免因防火墙或丢包造成的判断错误 。

这里以www.baidu.com为例：

1. ​	首先输入攻击目标和扫描方式

   ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207140922.png)

2. wireshark抓包

   ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207140954.png)

3. 只要目标回应，那么不论回复的是TCP-RST包还是其它，都认为目标机是存活的。



### 2、使用-sS TCP扫描开放端口

1. 这次我们自己使用命令扫描，不再使用内置的扫描配置

   ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207141024.png)

2. 我们使用了-p参数扫描了目的机的1-99号端口，扫描结果是只有23号端口打开，即目标机开启了telnet服务。那么其它的端口就是关闭的，我们先使用wireshark分析端口关闭的包，以80端口为例：

   ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207141057.png)

   我们可以很清楚的看到，攻击者向目标机发送了SYN包请求建立TCP连接，但是目标机回复的不是ACK，而是RST、ACK,即重置连接，说明此次连接无效。所以，Zenmap就是以此来推测目标机此端口是未开放的

3. 我们再查看开放的端口是什么样的情况：

   ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207141133.png)

   攻击者照例发送SYN包请求建立TCP连接，目标机回复了SYN、ACK表示可以建立TCP连接，并等待攻击者的ACK确认。但是攻击者却回复了RST包重置连接，此次连接作废。

   但是攻击者知道了目标机该端口是可达的，即有服务在监听。从而达到了端口扫描的目的。

   

### 3、使用-sT TCP扫描开放端口

1. 这次使用-sT选项扫描，-sT即 TCP Connect()扫描就是默认的TCP扫描 

   ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207141210.png)

2. 同样的方法，我们先查看未开放端口的数据包情况。我们发现-sT和-sS不同的地方在于，攻击者发送SYN包请求建立TCP连接，收到了目标机的SYN包拒绝后，再次发起了连接请求，总共请求了3次。但是3次都被目标机拒绝了。

   ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207141259.png)

3. 我们扫描到了23号端口是开放的，那么我们就看看其数据包的具体情况

   ![](https://cdn.jsdelivr.net/gh/zhyjc6/My-Pictures/2019/12/20191207141329.png)

   我们看到23号端口的数据包比较复杂，但是我们细细一看就会发现，这其实就是6组TCP连接，首先攻击者请求连接目标机，经过了三次握手后处于连接状态，此时攻击者发送一条RST、ACK包给目标机，表示此次连接作废。如此循环6次。其实一次连接就已经可以确定目标端口是开放的了，只不过为了提高扫描的准确率，需要重复几次。





